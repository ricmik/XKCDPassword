#requires -Version 2.0

function Get-CryptoRandom
{
    <#
    .Synopsis
       Gets a random number, or selects objects randomly from a collection.
    .DESCRIPTION
       The Get-CryptoRandom cmdlet gets a randomly selected number. If you submit a collection of objects to Get-CryptoRandom, it gets one or more randomly selected objects from the collection.
    
       Without parameters or input, a Get-CryptoRandom command returns a randomly selected 32-bit unsigned integer between 0 (zero) and Int32.MaxValue (0x7FFFFFFF, 2,147,483,647).
       
       You can use the parameters of Get-CryptoRandom to specify a seed number, minimum and maximum values, and the number of objects returned from a submitted collection.
    .PARAMETER Minimum
       Specifies a minimum value for the random number. Enter a 32-bit integer, a 64-bit integer, or a double-precision floating-point number, or an object that can be converted to an integer or double, such as a numeric string ("100").  The default value is 0 (zero).
    .PARAMETER Maximum
       Specifies a maximum value for the random number. Get-CryptoRandom returns a value that is less than the maximum (not equal). Enter a 32-bit integer or a double-precision floating-point number, or an object that can be converted to an integer or double, such as a numeric string ("100").
    .PARAMETER InputObject
       Specifies a collection of objects. Get-CryptoRandom gets randomly selected objects in random order from the collection. Enter the objects, a variable that contains the objects, or a command or expression that gets the objects. You can also pipe a collection of objects to Get-CryptoRandom.
    .PARAMETER Count
       Determines how many objects are returned. The default is 1. If the value of Count exceeds the number of objects in the collection, Get-CryptoRandom returns all of the objects in random order.
    .PARAMETER ByteCount
       Instructs Get-CryptoRandom to return an array of the specified size containing randomly-selected bytes.
    .EXAMPLE
       PS C:\>Get-CryptoRandom
       3951433
    
       This command gets a random integer between 0 (zero) and Int32.MaxValue.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -Maximum 100
       47
    
       This command gets a random integer between 0 (zero) and 99.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -Minimum -100 -Maximum 100
       56
    
       This command gets a random integer between -100 and 99.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -Minimum 10.7 -Maximum 20.93
       18.08467273887
    
       This command gets a random floating-point number greater than or equal to 10.7 and less than 20.93.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -ByteCount 8
       14
       215
       57
       249
       54
       160
       181
       7

       This command returns an array of type [System.Byte[]] containing 8 randomly-generated bytes.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -InputObject 1, 2, 3, 5, 8, 13
       8
    
       This command gets a randomly selected number from the specified array.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -InputObject 1, 2, 3, 5, 8, 13 -Count ([int]::MaxValue)
       2
       3
       5
       1
       8
       13
       
       This command returns the entire collection in random order. The value of the Count parameter is the MaxValue static property of integers.
       
       To return an entire collection in random order, enter any number that is greater than or equal to the number of objects in the collection.
    .EXAMPLE
       PS C:\>Get-CryptoRandom -InputObject "red", "yellow", "blue"
       yellow
    
       This command returns a random value from a non-numeric collection.
    .EXAMPLE
       PS C:\>get-process | Get-CryptoRandom
    
       Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
       -------  ------    -----      ----- -----   ------     -- -----------
       144           4     2080        488    36     0.48   3164 wmiprvse
       
       This command gets a randomly selected process from the collection of processes on the computer.
    .EXAMPLE
       PS C:\>Get-Content Servers.txt | Get-CryptoRandom -Count (Get-Content Servers.txt).Count | foreach {Invoke-Command -ComputerName $_ -Command 'Get-Process PowerShell'}
    
       This command runs a command on a series of remote computers in random order.
    .EXAMPLE
       PS C:\>$files = dir -Path C:\* -Recurse
       PS C:\>$sample = $files | Get-CryptoRandom -Count 50
       
       These commands get a randomly selected sample of 50 files from the C: drive of the local computer.
    .EXAMPLE
       PS C:\>Get-CryptoRandom 10001
       7600
       
       This command gets a random integer less than 10001. Because the Maximum parameter has position 1, you can omit the parameter name when the value is the first or only unnamed parameter in the command.
    .INPUTS
       System.Object
       You can pipe one or more objects to Get-CryptoRandom. Get-CryptoRandom selects values randomly from the piped objects.
    .OUTPUTS
       System.Int32, System.Int64, System.Double, System.Byte[]
       Get-CryptoRandom returns an integer or floating-point number, a byte array, or an object selected randomly from a submitted collection.
    .NOTES
       This function works almost exactly like the Get-Random cmdlet, except it uses the random number generator from the CryptoAPI instead of the System.Random pseudo-RNG.  The CryptoAPI's RNG is much slower, but also much more secure for highly sensitive applications (cryptography, finance, games of chance, etc.)

       The main differences in usage of this function, as compared to Get-Random, are that Get-CryptoRandom has no -SetSeed parameter, and has added a -Bytes parameter for returning simple arrays of random bytes.
    .LINK
       Get-Random
    #>

    [CmdletBinding(DefaultParameterSetName = 'RandomNumberParameterSet')]
    param(
        [Parameter(ParameterSetName = 'RandomNumberParameterSet', Position = 0)]
        [System.Object]
        $Maximum = [int]::MaxValue,
    
        [Parameter(ParameterSetName='RandomNumberParameterSet')]
        [System.Object]
        $Minimum = 0,
    
        [Parameter(ParameterSetName = 'RandomListItemParameterSet', Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Object[]]
        $InputObject,
    
        [Parameter(ParameterSetName = 'RandomListItemParameterSet')]
        [ValidateRange(1, 2147483647)]
        [int]
        $Count = 1,

        [Parameter(ParameterSetName = 'RandomByteArrayParameterSet')]
        [ValidateRange(1, 2147483647)]
        [int]
        $ByteCount
    )
    
    begin
    {
        $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::Create()
            
        if ($PSCmdlet.ParameterSetName -eq 'RandomListItemParameterSet')
        {
            $list = New-Object System.Collections.ArrayList
        }   

        function GetRandom($Min, $Max)
        {
            # $Min and $Max are assumed to be integral types.  (Int32 or Int64, based on the calling code,
            # which uses Get-Random's rules about the parameter types.)

            # This implementation ensures an even probability of choices, at some cost to speed (due to the
            # extra calculations required to set up the $maxRandom variable, and the slight potential for extra
            # calls to the RNG.)  The alternative would be to just return generate a random number once, and
            # return $Min + ($random % $range), ignoring the slight bias that might exist for the first N
            # values between Min and Max.

            # Unlike System.Random, this function returns a value between $Min and $Max (inclusive; $Max can be
            # returned.)  It's up to the calling code to decrement $Max by 1 to emulate the original cmdlet's
            # behavior.

            if ($Max -eq $Min)
            {
                return $Min
            }

            $range = $Max - $Min + 1

            $maxRandom = [uint64]::MaxValue
            $remainder = $maxRandom % $range
            
            if ($remainder -ne $range - 1)
            {
                $maxRandom -= $remainder + 1
            }

            $bytes = New-Object byte[](8)
            
            do
            {
                $rng.GetBytes($bytes)    
                $random = [System.BitConverter]::ToUInt64($bytes, 0)
            }
            until ($random -le $maxRandom)

            return $Min + ($random % $range)

        } # function GetRandom($Min, $Max)

        function GetRandomDouble($Min, $Max)
        {
            # This code is essentially lifed straight from the Get-Random cmdlet.  I don't fully understand it, but
            # it needed to be here to duplicate all of the cmdlet's original functionality (just replacing the use
            # of System.Random with the CryptoAPI RNG instead.)

            $range = $max - $min

            if ([double]::IsInfinity($range))
            {
                do
                {
                    # This next line produces a random Double greater than or equal to 0.0 and less than 1.0 (
                    # same as System.Random.NextDouble() )

                    $randomDouble = (GetRandom -Min 0 -Max ([int32]::MaxValue - 1)) * 4.6566128752458E-10
                    $returnValue = $min + $randomDouble * $max - $randomDouble * $min
                }
                while ($returnValue -ge $max)
            }
            else
            {
                do
                {
                    $randomDouble = (GetRandom -Min 0 -Max ([int32]::MaxValue - 1)) * 4.6566128752458E-10
                    $returnValue = $min + $randomDouble * $range

                    # This is the line that makes no sense at all to me, but it's straight out of the decompiled Get-Random cmdlet.
                    $range *= $randomDouble
                }
                while ($returnValue -ge $max)
            }

            return $returnValue

        } # function GetRandomDouble

        function ConvertToNumber($Value)
        {
            # Converts objects to int, int64, or double (in that order of preference), based loosely on the same
            # behavior as the original Get-Random cmdlet.

            if ($Value -is [int] -or $Value -is [int64] -or $Value -is [double])
            {
                return $Value
            }

            $methods = @(
                [Convert]::ToInt32
                [Convert]::ToInt64
                [Convert]::ToDouble
            )

            foreach ($method in $methods)
            {
                try
                {
                    return $method.Invoke($Value)
                } catch { }
            }

            throw "Value '$Value' could not be converted to an Int32, Int64 or Double."

        } # function ConvertToNumber($Value)

    } # begin
    
    process
    {
        if ($PSCmdlet.ParameterSetName -eq 'RandomListItemParameterSet')
        {
            # Get-Random's original implementation is written so that it only has to hold a maximum of $Count
            # input objects in memory; however, it looks like this creates a noticable bias toward the first
            # $Count objects, based on tests.  It's also much slower in terms of CPU time, as 1-2 calls to the
            # RNG have to be made for every input object in that version.

            # Here, we're just building the whole list and selecting randomly out of it in the end block.  This
            # is faster and produces even probability of choices, but with the downside of requiring the entire
            # input set to be held in memory temporarily (which may run into OutOfMemoryExceptions).

            $list.AddRange($InputObject)
        }
    }
    
    end
    {
        switch ($PSCmdlet.ParameterSetName)
        {
            'RandomByteArrayParameterSet'
            {
                $bytes = New-Object byte[]($ByteCount)
                $rng.GetBytes($bytes)

                Write-Output (,$bytes)

                break
            }

            'RandomListItemParameterSet'
            {
                $numberToReturn = [math]::Min($Count, $list.Count)

                for ($i = 0; $i -lt $numberToReturn; $i++)
                {
                    $random = GetRandom -Min $i -Max ($list.Count - 1)
                    $list[$i], $list[$random] = $list[$random], $list[$i]

                    Write-Output (,$list[$i])
                }

                break
            }

            'RandomNumberParameterSet'
            {
                try
                {
                    $min = ConvertToNumber($Minimum)
                    $max = ConvertToNumber($Maximum)
                }
                catch
                {
                    throw
                }

                if ($min -ge $max)
                {
                    throw "The Minimum value ($min) cannot be greater than or equal to the Maximum value ($max)."
                }

                if ($min -is [double] -or $max -is [double])
                {
                    Write-Output (GetRandomDouble -Min $min -Max $max)
                }
                else
                {
                    # The GetRandom helper function can return $Max as a value.  To emulate the original functionality of Get-Random,
                    # we'll use $max - 1 as our top value.

                    Write-Output (GetRandom -Min $min -Max ($max - 1))
                }
                
                break
            }

        } # switch ($PSCmdlet.ParameterSetName)

    } # end

} # function Get-Random
